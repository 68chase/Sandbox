# Copyright 2012 United States Government, as represented by the Secretary of Defense, Under
# Secretary of Defense (Personnel & Readiness).
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.
---

extends: prim.vwf
properties:
  _initialized: false
  radius:
    set: |
            
            this.radius = value;
            this.radius = Math.max(this.radius,.001);
            if(this._initialized == true)
            this.dirtyStack();
  height:
    set: |
            this.height = value;
            this.height = Math.max(this.height,.001);
            if(this._initialized == true)
            this.dirtyStack();
  heightsegments:
    set: |
            this.heightsegments = value;
            this.heightsegments = Math.max(this.heightsegments,3);
            this.heightsegments = Math.min(this.heightsegments,12);
            this.heightsegments = Math.floor(this.heightsegments);
            this.heightsegments = this.heightsegments==11?12:this.heightsegments;
            this.heightsegments = this.heightsegments==9?11:this.heightsegments;
            this.heightsegments = this.heightsegments==10?11:this.heightsegments;
            if(this._initialized == true)
            this.dirtyStack();
  radialsegments:
    set: |
            this.radialsegments = value;
            this.radialsegments = Math.max(this.radialsegments,3);
            this.radialsegments = Math.min(this.radialsegments,20);
            this.radialsegments = Math.floor(this.radialsegments);
            if(this._initialized == true)
            this.dirtyStack();
  base2pivot:
    set: |
            this.base2pivot = value;
            if(this._initialized == true)
            this.dirtyStack();            
  EditorData:
    radius:
      displayname: radius
      property: radius
      type: slider
      min: 0
      max: 20
      step: .1
    rsegments:
      displayname: radial segments
      property: radialsegments
      type: slider
      min: 3
      max: 20
      step: 1
    height:
      displayname: height
      property: height
      type: slider
      min: 0
      max: 20
      step: .01
    hsegments:
      displayname: height segments
      property: heightsegments
      type: slider
      min: 3
      max: 12
      step: 1
    base2pivot:
      displayname: pivot from base
      property: base2pivot
      type: check  
events:
  pointerOver:
  pointerOut:
  pointerUp:
  pointerDown:
  pointerMove:
  pointerClick:
scripts:
- |
    this.initialize = function(){
        
        
        if(this.uri == "cylinder.vwf")
            return;

       var primobj = new GLGE.Object();
       
       this.mesh = primobj;
       if(vwf.getProperty(this.id,'radius') == undefined) vwf.setProperty(this.id,'radius',1);
       if(vwf.getProperty(this.id,'height') == undefined) vwf.setProperty(this.id,'height',1);
       if(vwf.getProperty(this.id,'heightsegments') == undefined) vwf.setProperty(this.id,'heightsegments',2);
       if(vwf.getProperty(this.id,'radialsegments') == undefined) vwf.setProperty(this.id,'radialsegments',12);
       if(vwf.getProperty(this.id,'base2pivot') == undefined) vwf.setProperty(this.id,'base2pivot',false);
       
       vwf.views[0].state.nodes[this.id].glgeObject.addChild(this.mesh);
       
      
       this._initialized = true;
       window.setTimeout(this.dirtyStack.bind(this),500);
       window.setTimeout(this.setupMaterial.bind(this),500);        
    }
    this.Build = function()
    {
        var radius = vwf.getProperty(this.id,'radius');
        var height = vwf.getProperty(this.id,'height');
        var heightsegments = vwf.getProperty(this.id,'heightsegments');
        var radialsegments = vwf.getProperty(this.id,'radialsegments');
        var base2pivot= vwf.getProperty(this.id,'base2pivot');
        return this.BuildCylinder(height,radius,heightsegments,radialsegments,base2pivot);   
    }

    this.BuildCylinder =function(height,radius,heightsteps,rsteps,base2pivot)
    {
        
        var rv = [radius,0,0];
            
        var positions = [];
        var normals = [];
        var colors = [];
        var faces = [];
        var uvs = [];
        var z_rot = 0;
        
        var segs = Math.floor(rsteps/2);
        var zinc = 180/segs;
        
        for(var band = 0; band <= height; band+= height/heightsteps)        
        for(z_rot = 0; z_rot <= 360; z_rot += zinc)
        {
        
            uvs.push((z_rot + 90)/180);
            uvs.push(band/height);
            var zmatrix = GLGE.angleAxis(z_rot*0.0174532925,[0,0,1]);
            var offset = GLGE.mulMat4Vec3(zmatrix,rv);
            
            var length = GLGE.lengthVec3(offset);
            var normal = GLGE.scaleVec3(offset,1/length);
            normals.push(normal[0]);
            normals.push(normal[1]);
            normals.push(normal[2]);
            offset[2] = band;
            positions.push(offset[0]);
            positions.push(offset[1]);
            if(base2pivot == true)
                positions.push(offset[2]);
            else
                positions.push(offset[2]-height/2);
        }
        
         for(var band = 0; band < heightsteps; band+= 1)
            {
                for(z_rot = 0; z_rot <= 360/zinc + heightsteps-1; z_rot += 1)
                {
                    var ynum = ( (360/zinc)*band);
                    var ynum1 = ( (360/zinc)*(band+1));
                    var znum = z_rot;
                    var znum1 = (z_rot + 1);
                   
                    faces.push(ynum+znum);
                    faces.push(ynum1+znum);
                    faces.push(ynum1+znum1);
                    
                    faces.push(ynum1+znum1);
                    faces.push(ynum+znum);
                    faces.push(ynum+znum1);;
                }
            }
            
        var capindexstart = positions.length/3-1;    
        for(var capnum = 0; capnum <= 2; capnum+= 1)        
        for(z_rot = 0; z_rot <= 360; z_rot += zinc)
        {
        
            //uvs.push((z_rot + 90)/180);
           // uvs.push(band/height);
            var zmatrix = GLGE.angleAxis(z_rot*0.0174532925,[0,0,1]);
            offset = GLGE.mulMat4Vec3(zmatrix,rv);
            
            var length = GLGE.lengthVec3(offset);
            var normal = GLGE.scaleVec3(offset,1/length);
            
            uvs.push((offset[1]/radius)/2);
            uvs.push((offset[0]/radius)/2);
            normals.push(0);
            normals.push(0);
            normals.push(capnum == 0 ? -1: 1);
            offset[2] = capnum == 0 ? 0: height;
            positions.push(offset[0]);
            positions.push(offset[1]);
            if(base2pivot == true)
                positions.push(offset[2]);
            else
                positions.push(offset[2]-height/2);
        }
       
        for(var i = capindexstart; i < capindexstart+360/zinc -1;i++)
        {
            faces.push(capindexstart+1);
            faces.push(i+1);
            faces.push(i+2);
        }
        capindexstart += 360/zinc + 1;
        for(var i = capindexstart; i < capindexstart+360/zinc -1;i++)
        {
            faces.push(capindexstart+1);
            faces.push(i+1);
            faces.push(i+2);
        }

        var planemesh = new GLGE.Mesh();
          
            planemesh.setPositions(positions);
            planemesh.setFaces(faces);
            planemesh.setNormals(normals);
            planemesh.setUV(uvs);
      
            return planemesh;
    }
   
   
    function findChildViewNode(node, name)
    {
        if(node.vwfID == name)
            return node;
        else if(node.children){
            for(var i = 0; i < node.children.length; i++) {
                var child = findChildViewNode(node.children[i],name);
                if(child) return child;
            }
        }
        return null;
    }
    function findVWFscene()
    {
         return  vwf.models[0].model.nodes["index-vwf"];
    }
    function findscene()
    {
         for(var i =0; i<vwf.views.length;i++)
         {
             if(vwf.views[i].module.id = 'vwf/view/glge') return vwf.views[i].state.scenes["index-vwf"].glgeScene;
         }
         return null;
    }