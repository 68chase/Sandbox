# Copyright 2012 United States Government, as represented by the Secretary of Defense, Under
# Secretary of Defense (Personnel & Readiness).
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.
---

extends: http://vwf.example.com/node3.vwf
properties:
  translation:
  rotZ: 0       
  test:  
methods:
  update:
  tick:
events:
  pointerOver:
  pointerOut:
  keyUp:
  keyDown:
scripts:
- |

    this.initialize = function(){
        
        if(this.id == 'character.vwf') return;
       
         this.DownKeys= [];
         this.motionStack= [];
         this.jumpcounter = 0;
        
       
       
        
       
        
        if(this.hasOwnProperty('PlayerNumber') == false) return;
        var PlayerNumber = vwf.getProperty(this.id,'PlayerNumber');
        
        
        if(!document[PlayerNumber + 'link'])
        {
            //this.parent.players.push(PlayerNumber); 
            document[PlayerNumber +'link'] = this;
            _UserManager.PlayerCreated(PlayerNumber,this.id);
           
        }
        
       
        
        
        this.originalvelocity = [0,0,0];
        this.updateCallbacks = [];
         if(document.PlayerNumber == PlayerNumber)
          {
            
            
            //findVWFscene().followObject(this);
            
          }
         
         this.cycles = 
            {
                stand:{start:0,length:0,speed:1.25,current:0,loop:false},
                walk:{start:0,length:30,speed:1.25,current:0,loop:true},
                straferight:{start:31,length:29,speed:1.5,current:0,loop:true},
                strafeleft:{start:31,length:29,speed:-1.5,current:0,loop:true},
                walkback:{start:0,length:30,speed:-1.25,current:0,loop:true},
                run:{start:60,length:30,speed:1.25,current:0,loop:true},
                jump:{start:90,length:48,speed:1.25,current:0,loop:false},
                runningjump:{start:109,length:48,speed:1.25,current:0,loop:false}
            };
          this.prerendercallback = this.placeNameTag.bind(this);
          $(document).bind('prerender',this.prerendercallback);
          //this.callbacknum = findVWFscene().addUpdateCallback(this.placeNameTag.bind(this));
          this.updatecounter = 0;
          this.mesh = findChildViewNode(findscene(),this.id);
          this.mesh.children[0].children[0].position.z = -.85
          this.skin = this.mesh.children[0].children[0].children[1];
          this.jumpcounter = 0.0;
          this.stand();
         
          this.createNameTag(PlayerNumber);
          this.followOffset = [0,0,1.733];
          this.initCycles();
          this.activeCycle = this.cycles.stand;
          this.updateLoopStarted = false;
          var now = performance.now();
          this.lastUpdate = now;
          //window.setTimeout(function(){document[PlayerNumber +'link'].startloop();},500);
    }
    this.pointerOver = function(e)
    {
        
    }
    this.pointerOut = function(e)
    {
        
    }
    this.initCycles = function()
    {
        for(var i in this.cycles)
        {
            this.cycles[i].getFrame = function() { 
                    return this.current + this.start;
                }.bind(this.cycles[i]);
            this.cycles[i].increment = function(steps) { 
                    this.current+=this.speed * steps;
                    if(this.current >= this.length && this.loop == true)
                        this.current = 0;
                    if(this.current < 0 && this.loop == true)
                        this.current = this.length;    
                    if(this.current >= this.length && this.loop == false)
                        this.current = this.length-1;
                    return this.getFrame();
                }.bind(this.cycles[i]);
            this.cycles[i].reset = function() {
                    this.current=0;
            }.bind(this.cycles[i]);
        }
    }
    this.createNameTag = function(PlayerNumber)
    {
    
      var newdiv = document.createElement('div');
      $(newdiv).attr('style',"text-transform: uppercase; font-weight: bold; position: fixed; left: 612.7792636991876px; top: 350.056008871367px; color: white; text-shadow: black 0.1em 0.1em 0.4em; ");
      newdiv.style.position = 'fixed';
      newdiv.id = "Player " + PlayerNumber + 'label';
      newdiv.innerHTML = "" + PlayerNumber;
      newdiv.style.left = '0px';
      newdiv.style.top = '0px';
      
      $(document.body).append(newdiv);
      $(newdiv).disableSelection();
      this.nametag = newdiv;
                 
    }
    this.deinitialize = function()
    {
       //findVWFscene().removeUpdateCallback(this.callbacknum);
       $(document).unbind('prerender',this.prerendercallback);
        _UserManager.PlayerDeleted(this.PlayerNumber);
       //this.deleteMe = true;            
       $(this.nametag).remove()
       
    }
    this.placeNameTag = function(e,viewprojection)
    {
      if(!this.ownerClientID || ! this.prevTranslation || !this.currentTranslation)  
        return;
      var now = performance.now();	
      var timediff =  now - this.lastUpdate;
      timediff = timediff/50.0;
      timediff = Math.min(timediff,1.0);
      
       //profile shows this is too slow!
      if(false && this.prevframe !=   this.currentframe    )
      {      
        this.skin.morphTargetInfluences[parseInt(this.prevframe)] = 1.0-timediff;
        this.skin.morphTargetInfluences[parseInt(this.currentframe)] = timediff;     
      }
      
      var slicedTrans = [0,0,0];
      slicedTrans[0] = this.prevTranslation[0]*(1.0-timediff) + this.currentTranslation[0]  * timediff;    
      slicedTrans[1] = this.prevTranslation[1]*(1.0-timediff) + this.currentTranslation[1]  * timediff;
      slicedTrans[2] = this.prevTranslation[2]*(1.0-timediff) + this.currentTranslation[2]  * timediff;
      
      //seems like this might break replication slightly
      //this.translation =  slicedTrans;    
      //this.quaternion = goog.vec.Quaternion.slerp(this.prevQuat,this.currentQuat,timediff,[0,0,0,0]);
      
      
      var rootdiv = document.getElementById('index-vwf');
      var h = rootdiv.style.height;
      var w = rootdiv.style.width;
      var wh = parseInt(h.substr(0,h.length-2));
      var ww = parseInt(w.substr(0,w.length-2));
      var div = this.nametag;
      var pos = this.translation;
      pos = [pos[0],pos[1],pos[2]+1.620,1];
         
      
      
      var screen = MATH.mulMat4Vec4(viewprojection,pos);
      screen[0] /= screen[3];
      screen[1] /= screen[3];
     
      screen[0] /= 2;
      screen[1] /= 2;
      screen[2] /= 2;
      screen[0] += .5;
      screen[1] += .5;
      
  
      screen[0] *= ww;
      screen[1] *= wh;
      
     
      screen[1] = wh - screen[1];

      div.style.top = (screen[1])  +  'px';
      div.style.left = (screen[0] - div.offsetWidth/2)  +'px';
     
     
      if((screen[0] < 0 || screen[0] > ww || screen[1] < 0 || screen[1] > wh))
      {
            if(div.style.display != 'none')
                div.style.display = 'none';
      }
      else
      {
          if((screen[2] > 10 || screen[2] < 0) && div.style.display != 'none')
             div.style.display = 'none';
          if(screen[2] < 10 && screen[2] > 0 && div.style.display == 'none')
             div.style.display = 'block';
      }
         
      
         
    }
    this.startloop = function()
    {
        if(this.updateLoopStarted == false)
        {
            this.update(this.moniker);
            this.updateLoopStarted = true;
        }
    }
    this.update = function(moniker)
    {
        var time = new Date();
        this.prevTranslation = [this.translation[0],this.translation[1],this.translation[2]];
        this.prevQuat = [this.quaternion[0],this.quaternion[1],this.quaternion[2],this.quaternion[3]];
        this.updatecounter++;
        var updateFreqDivisor = 1;
        
        if(this.id == 'character-vwf') return;
       
        
        //if(this.moniker != moniker)
        // return;

        //if(this.deleteMe == true)
        //{
         //   var id = this.id;
            
         //   var div = document.getElementById("Player " + this.PlayerNumber + 'label');
         //   div.parentNode.removeChild(div);
         //   document[this.PlayerNumber + 'link'] = null;
         //   vwf.deleteNode(this.id);
            
           
         //   return;
        //}
        
       // this.mesh.setRotZ(this.rotZ);
          this.rotation = [0,0,1,this.rotZ/0.0174532925];
        
        //this.placeNameTag();
        var standing = 1.703559666;
        if(this.activeCycle)
        {
            
            var newframe = this.activeCycle.increment(updateFreqDivisor);
            newframe = Math.max(newframe,0);
            if(this.currentframe != newframe)
            {
                
               
               // this.mesh.setStartFrame(newframe,0,false);
               for(var i = 0; i < this.skin.morphTargetInfluences.length; i++)
                    this.skin.morphTargetInfluences[i] = 0;
               
               this.skin.morphTargetInfluences[parseInt(newframe)] = 1;     
            }
            this.prevframe = this.currentframe;
            this.currentframe = newframe;
        }
        
        
        
        var originalpos = [this.translation[0],this.translation[1],this.translation[2]];
        var originalpos2 = [this.translation[0],this.translation[1],this.translation[2]].slice(0);
        //console.log("t:" + [this.translation[0],this.translation[1],this.translation[2]]);
        if(this.motionStack.length == 0)
            this.stand();
        
        var motionvec = null;
        for(var i=0; i < this.motionStack.length; i++)
        {
            this.cycleName =  this.motionStack[i];
            if(this.cycleName == 'turnright')
            {
                this.rotZ += -.07*updateFreqDivisor;
               // this.mesh.setRotZ(this.rotZ);
               this.rotation = [0,0,1,this.rotZ/0.0174532925];
            }
            if(this.cycleName == 'turnleft')
            {
                this.rotZ += +.07*updateFreqDivisor;
               // this.mesh.setRotZ(this.rotZ);
               this.rotation = [0,0,1,this.rotZ/0.0174532925];
            }
             if(this.cycleName == 'straferight')
            {
                 motionvec = MATH.mulMat4Vec3(MATH.angleAxis(this.rotation[3]*0.0174532925,[this.rotation[0],this.rotation[1],this.rotation[2]]),[-.03*updateFreqDivisor,0,0]);
                 this.translation = MATH.addVec3(motionvec,this.translation);
            }
            if(this.cycleName == 'strafeleft')
            {
                 motionvec = MATH.mulMat4Vec3(MATH.angleAxis(this.rotation[3]*0.0174532925,[this.rotation[0],this.rotation[1],this.rotation[2]]),[.03*updateFreqDivisor,0,0]);
                 this.translation = MATH.addVec3(motionvec,this.translation);
            }
            if(this.cycleName == 'walk')
            {
                    motionvec = MATH.mulMat4Vec3(MATH.angleAxis(this.rotation[3]*0.0174532925,[this.rotation[0],this.rotation[1],this.rotation[2]]),[0,-.06*updateFreqDivisor,0]);
                    this.translation = MATH.addVec3(motionvec,this.translation);
            }
            if(this.cycleName == 'walkback')
            {
                    motionvec = MATH.mulMat4Vec3(MATH.angleAxis(this.rotation[3]*0.0174532925,[this.rotation[0],this.rotation[1],this.rotation[2]]),[0,+.06*updateFreqDivisor,0]);
                    this.translation = MATH.addVec3(motionvec,this.translation);
            }
            if(this.cycleName == 'run')
            {
                    motionvec = MATH.mulMat4Vec3(MATH.angleAxis(this.rotation[3]*0.0174532925,[this.rotation[0],this.rotation[1],this.rotation[2]]),[0,-.140*updateFreqDivisor,0]);
                    this.translation = MATH.addVec3(motionvec,this.translation);
            }
            if(this.cycleName == 'jump')
            {  
                var preptime = 5.5;
                var height = 36;
                var heighttimeoffset = Math.sqrt(height);
                var hangtime = 17;
                if(this.jumpcounter >= (hangtime+preptime+preptime))
                {
                
                    this.removeMotion('jump');
                    if(this.inMotion('walk'))
                    {
                        this.removeMotion('walk');
                        this.walk();
                    }
                    if(this.inMotion('run'))
                    {
                        this.removeMotion('run');
                        this.run();
                    }
                    this.jumpcounter  = 0;
                }
                
                var jumpamt = 0;
                if(this.jumpcounter < preptime)
                    jumpamt = -(this.jumpcounter * 0);
                else if(this.jumpcounter > hangtime+preptime)
                    jumpamt = -((hangtime+preptime+preptime)-this.jumpcounter) * 0;
                else    
                {
                    var x = this.jumpcounter - preptime;
                    jumpamt = .080*((-((x/1.4)-heighttimeoffset)*((x/1.4)-heighttimeoffset))+height) -(preptime * 0) ;
                }
                
                this.translation = [this.translation[0],this.translation[1],this.jumpstart + jumpamt];
                this.jumpcounter += ((hangtime+preptime+preptime)/39.0) *updateFreqDivisor;
            }
            
        }
        
        
            //if the character is not completely still, and they're not jumpping, then check their motion vector 
            //for intersetions, and prevent penetration through objects
            if((MATH.lengthVec3(this.originalvelocity) > .001 || motionvec) && !this.inMotion('jump') && this.activeCycle != this.cycles.stand)
            {
                this.skin.PickPriority = -1;
                
                //var forward = MATH.mulMat4Vec3(MATH.angleAxis(this.rotation[3]*0.0174532925,[this.rotation[0],this.rotation[1],this.rotation[2]]),[0,-1,0]);
               
                motionvec = MATH.toUnitVec3(motionvec);
                var testpos = MATH.subVec3(this.translation,MATH.scaleVec3(motionvec,-.15));
                
                var intersectfront = _Editor.ThreeJSPick(MATH.addVec3(testpos,[0,0,1]),motionvec,{ignore:[this.skin,_Editor.GetMoveGizmo()]});
                if(intersectfront)
                {
                    if(intersectfront.distance < .3)
                    {
                        
                        var offset = MATH.subVec3(originalpos,this.translation);
                        var len = MATH.lengthVec3(offset);
                        offset = MATH.scaleVec3(offset,1/MATH.lengthVec3(offset));
                        var norm = [intersectfront.norm[0],intersectfront.norm[1],intersectfront.norm[2]];
                        console.log(norm);
                        if(Math.abs(norm[0]) < .05) norm[0] = 0;
                        if(Math.abs(norm[1]) < .05) norm[1] = 0;
                        if(Math.abs(norm[2]) < .05) norm[2] = 0;
                        
                        var R = MATH.scaleVec3(norm,.3 - intersectfront.distance); 
                        
                        this.translation = MATH.addVec3(this.translation,R);
                    }
                }
                var falldist = 1000;
               
                var intersect = _Editor.ThreeJSPick(MATH.addVec3(this.translation,[0,0,1.7]),[0,0,-1],{ignore:[this.skin,_Editor.GetMoveGizmo()]});
                //console.log(intersect.distance);
                //console.log(intersect);
               
                falldist = intersect?intersect.distance:falldist;
                if( falldist)
                {
                    //console.log(intersect.distance);
                    var zdiff = standing - falldist;
                    //console.log(zdiff);
                    var zmove = zdiff;
                    if(zdiff < -.03 )
                    {
                       zmove = this.originalvelocity[2] - 1.0/24; 
                       
                       this.translation = MATH.addVec3(this.translation, [0,0,zmove]);
                    }   
                    else if(zdiff > .33 )
                    {   
                       //console.log("o:" + [originalpos2[0],originalpos2[1],originalpos2[2]]);
                       this.translation = [originalpos2[0],originalpos2[1],originalpos2[2]];
                       
                    }
                    else
                    {
                        this.translation = MATH.addVec3(this.translation, [0,0,zmove/3]);
                    }
                }
                this.skin.PickPriority = 1;
                
            }
            //if they are jumpping, and have been for more than a 10th of a second, start checking below them for intersections.
            //10th of second is where they start falling?
            if(this.inMotion('jump') && this.jumpcounter > 10)
            {
                this.skin.PickPriority = -1;
                var intersect = _Editor.ThreeJSPick(MATH.addVec3(this.translation,[0,0,2]),[0,0,-1],{ignore:[this.skin,_Editor.GetMoveGizmo()]});
                if(intersect)
                {
                    //console.log(zdiff);
                    var zdiff = standing - intersect.distance;
                   
                    //in this case, they've jumpped onto something
                    if(zdiff > 0.17 )
                    {
                        
                        var zdiff = standing - intersect.distance;
                        //console.log(zdiff);
                        var zmove = zdiff;
                        this.translation = MATH.addVec3(this.translation, [0,0,zmove]);
                        this.removeMotion('jump');
                        this.jumpcounter  = 0;
                    }
                }
                this.skin.PickPriority = 1;
            }
            
        
        this.originalvelocity[2] = 0;
        // keep track of how fast they were moving at this frame, so we can accelerate properly
        this.originalvelocity = MATH.subVec3(this.translation,originalpos);
        //permenantly clamp to z=0 plane
        if(this.translation[2] < 0)
            this.translation = [this.translation[0],this.translation[1],0];
        //every 2 seconds, update the position and rotation that tend to run out of sync
        //note that we could change the update mechanism to avoid getting out of sync
        if(this.updatecounter > 80 && document["PlayerNumber"] == this.PlayerNumber)
          {
            console.log('sent update');
            vwf_view.kernel.setProperty(this.id,'transform',this.transform,0,null);
             this.updatecounter = 0;
          }
          
        for(var i = 0; i < this.updateCallbacks.length; i++)
        {
        
            this.updateCallbacks[i](this);
        }
        //vwf.plan(this.id,'callMethod','update',[],-1.0/30,null);
        //this.future(1.0/30).update(this.moniker);
        
        var now = performance.now();
        this.lastUpdate = now;
        this.currentTranslation = [this.translation[0],this.translation[1],this.translation[2]];
        this.currentQuat = [this.quaternion[0],this.quaternion[1],this.quaternion[2],this.quaternion[3]];
        this.skin.PickPriority = 1;
    }
    this.tick = function()
    {
        var time = new Date();
      if(this.id == 'character-vwf') return;
      try{
        this.update();
        }catch(e){}
        var time2 = new Date();
        var t = time2-time;
        
        
    }
     function findChildViewNode(node, name)
     {
        if(node == null)
            return null;
        if(node.vwfID == name)
            return node;
        
        else if(node && node.children){
            for(var i = 0; i < node.children.length; i++) {
                var child = findChildViewNode(node.children[i],name);
                if(child) return child;
            }
        }
        return null;
     }
     function findVWFscene()
     {
         
          return   vwf.models[0].model.nodes["index-vwf"];
         
         return null;
     }
     function findscene()
     {
             return vwf.views[0].state.scenes["index-vwf"].threeScene;
     }
     
    this.markKeyDown =function(m)
    {
        if(this.DownKeys.indexOf(m) != -1) return;
        this.DownKeys.push(m);
    }
    this.KeyIsDown=function(m)
    {
        return (this.DownKeys.indexOf(m) != -1);
    }
    this.markKeyUp=function(m)
    {
        if(this.DownKeys.indexOf(m) == -1) return;
               this.DownKeys.splice(this.DownKeys.indexOf(m),1);
    }
    
    this.addMotion =function(m)
    {
        if(this.motionStack.indexOf(m) != -1) return;
        this.motionStack.push(m);
    }
    this.inMotion=function(m)
    {
        return (this.motionStack.indexOf(m) != -1);
    }
    this.removeMotion=function(m)
    {
        if(this.motionStack.indexOf(m) == -1) return;
               this.motionStack.splice(this.motionStack.indexOf(m),1);
    }
    this.exclusiveMotion=function(m)
    {
        this.motionStack = [m];
    }     
    this.walk = function()
    {
        if(this.inMotion('walk'))return;
        if(this.inMotion('jump'))return;
        this.addMotion('walk');
        this.activeCycle = this.cycles.walk;
    }
    this.walkback = function()
    {
        if(this.inMotion('walkback'))return;
        if(this.inMotion('jump'))return;
        this.addMotion('walkback');
        this.activeCycle = this.cycles.walkback;
    }
    this.run = function()
    {
        if(this.inMotion('run'))return;
        if(this.inMotion('jump'))return;
        this.addMotion('run');
        this.activeCycle = this.cycles.run;
    }
    this.cancelRun = function()
    {
        if(!this.inMotion('run'))return;
        this.removeMotion('run');
        if(this.inMotion('walk'))
        { 
            this.removeMotion('walk');
            this.walk();
        }
    }
    this.stand = function()
    {
        this.motionStack = [];
        this.activeCycle = this.cycles.stand;
    }
    this.jump = function()
    {
        if(this.inMotion('walkback'))return;
        if(this.inMotion('jump'))return;
        this.addMotion('jump');
        this.jumpcounter = 0;
        this.cycles.jump.reset();
        this.activeCycle = this.cycles.jump;
        this.jumpstart = this.translation[2];
       
    }   
    this.runningjump = function()
    {
       
        if(this.inMotion('jump'))return;
        this.addMotion('jump');
        this.jumpcounter = 0;
        this.cycles.runningjump.reset();
        this.activeCycle = this.cycles.runningjump;
       
    }      

    this.keyUp = function(e)
         {          
             if(this.id == 'character-vwf') return;
            if(vwf.client() != this.ownerClientID) return;
            if(!e.keysDown.W)
                this.removeMotion('walk');
            if(!e.keysDown.S)
                this.removeMotion('walkback');    
            if(!e.keysDown.D)
                {this.removeMotion('straferight'); this.removeMotion('strafeleft');}
            if(!e.keysDown.C)
                {this.removeMotion('turnright'); this.removeMotion('turnleft');}    
            if(!e.keysDown.A)
                {this.removeMotion('strafeleft');this.removeMotion('straferight');}
            if(!e.keysDown.Z)
                {this.removeMotion('turnleft'); this.removeMotion('turnright');}        
            if(!e.keysDown.W && this.inMotion('run'))
                this.cancelRun();       
            
         }
    this.keyDown = function(e)
         {
            if(this.id == 'character-vwf') return;
           if(vwf.client() != this.ownerClientID) return;
            if(e.keysDown.W)
                this.walk();
            if(e.keysDown.S)
                this.walkback();
            if(e.keysDown.space && !e.mods.shift)
            {
                if(!this.inMotion('run'))
                    this.jump();
                else
                    this.runningjump();
            }
            if(e.keysDown.D && !this.inMotion('walkback'))
               { this.addMotion('straferight');  this.activeCycle = this.cycles.straferight;  }
            if(e.keysDown.D && this.inMotion('walkback'))
               { this.addMotion('strafeleft');  this.activeCycle = this.cycles.strafeleft;  }
            if(e.keysDown.A && !this.inMotion('walkback'))
               { this.addMotion('strafeleft');    this.activeCycle = this.cycles.strafeleft;   }
            if(e.keysDown.A && this.inMotion('walkback'))
               { this.addMotion('straferight');   this.activeCycle = this.cycles.straferight;   }
               
             if(e.keysDown.C && !this.inMotion('walkback'))
               { this.addMotion('turnright');   }
            if(e.keysDown.C && this.inMotion('walkback'))
               { this.addMotion('turnleft');    }
            if(e.keysDown.Z && !this.inMotion('walkback'))
               { this.addMotion('turnleft');      }
            if(e.keysDown.Z && this.inMotion('walkback'))
               { this.addMotion('turnright');    }
            if(e.mods.shift && e.keysDown.W)
                this.run();    
         }
    