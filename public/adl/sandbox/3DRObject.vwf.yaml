# Copyright 2012 United States Government, as represented by the Secretary of Defense, Under
# Secretary of Defense (Personnel & Readiness).
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.
---
extends: http://vwf.example.com/node3.vwf
methods:
  GetMesh:
  updateStack:
  updateSelf:
  dirtyStack:
  GetBounds:
  initTexture:
  getTexture:
  setupMaterial:
  backupMesh:
  restoreMesh:
  initialize:
properties:
  materialDef:
    get: |
            return this.getTexture();
    set: |
             
             this.materialDef = value;
             this.initTexture(value);
scripts: 
- |  
    this.getTexture = function()
    {
            if(this.materialDef) return this.materialDef;    
            if(!this.GetMesh())
                return null;
            var newMaterial = {};
            var currentMaterial = this.GetMesh().getMaterial();
            if(!currentMaterial)
                return;
            newMaterial.shininess = currentMaterial.getShininess();
            newMaterial.alpha = currentMaterial.getAlpha();
            newMaterial.ambient = currentMaterial.getAmbient();
            newMaterial.color = currentMaterial.getColor();
            newMaterial.emit = currentMaterial.getEmit();
            newMaterial.reflect = currentMaterial.getReflectivity();
            newMaterial.shadeless = currentMaterial.getShadeless();
            newMaterial.shadow = currentMaterial.getShadow();
            
            newMaterial.specularColor = currentMaterial.getSpecularColor();
            newMaterial.specularLevel = Math.sqrt(newMaterial.specularColor.r * newMaterial.specularColor.r + newMaterial.specularColor.g * newMaterial.specularColor.g + newMaterial.specularColor.b * newMaterial.specularColor.b);
            newMaterial.specularColor.r = newMaterial.specularColor.r/newMaterial.specularLevel || 0.01;
            newMaterial.specularColor.g = newMaterial.specularColor.g/newMaterial.specularLevel || 0.01;
            newMaterial.specularColor.b = newMaterial.specularColor.b/newMaterial.specularLevel || 0.01;
            newMaterial.layers = [];
            for(var i = 0; i<currentMaterial.layers.length;i++)
            {
                var newLayer = {};
                newMaterial.layers.push(newLayer);
                newLayer.src = currentMaterial.layers[i].getTexture().getSrc();
                newLayer.mapTo = currentMaterial.layers[i].getMapto();
                newLayer.blendMode = currentMaterial.layers[i].getBlendMode();
                newLayer.alpha = currentMaterial.layers[i].getAlpha();
                
                newLayer.scalex = currentMaterial.layers[i].getScaleX();
                newLayer.scaley = currentMaterial.layers[i].getScaleY();
                newLayer.offsetx = currentMaterial.layers[i].getOffsetX();
                newLayer.offsety = currentMaterial.layers[i].getOffsetY();
                newLayer.rot = currentMaterial.layers[i].getRotZ();
                newLayer.mapInput = currentMaterial.layers[i].getMapinput();
            }            
            return newMaterial;
    
    }
    this.initialize = function()
    {
        this.dirtyStack();
    }
    this.initTexture = function(value)
    {
           
             var newMaterial = value || vwf.getProperty(this.id,'materialDef') ;//|| {shininess:10,alpha:1,ambient:{r:0,g:0,b:0},color:{r:1,g:1,b:1},emit:{r:0,g:0,b:0},reflect:.08,shadeless:false,shadow:true};
             if(!newMaterial) return;
             var currentMaterial = this.GetMesh().getMaterial();
             if(!this.GetMesh().originalMaterial)
             {
                this.GetMesh().originalMaterial = currentMaterial;
                currentMaterial = new GLGE.Material();
                this.GetMesh().setMaterial(currentMaterial);
             }
             if(!currentMaterial) return;
             currentMaterial.setShininess(newMaterial.shininess);
             currentMaterial.setAlpha(newMaterial.alpha);
             currentMaterial.setAmbient(newMaterial.ambient);
             currentMaterial.setColor(newMaterial.color);
             currentMaterial.setEmit(newMaterial.emit);
             currentMaterial.setReflectivity(newMaterial.reflect);
             currentMaterial.setShadeless(newMaterial.shadeless);
             currentMaterial.setShadow(newMaterial.shadow);
 
             newMaterial.specularColor.r = newMaterial.specularColor.r || 0.01;
             newMaterial.specularColor.g = newMaterial.specularColor.g || 0.01;
             newMaterial.specularColor.b = newMaterial.specularColor.b || 0.01;
 
             var norm = Math.sqrt(newMaterial.specularColor.r * newMaterial.specularColor.r + newMaterial.specularColor.g * newMaterial.specularColor.g + newMaterial.specularColor.b * newMaterial.specularColor.b);
             newMaterial.specularColor.r /= norm;
             newMaterial.specularColor.g /= norm;
             newMaterial.specularColor.b /= norm;
 
             newMaterial.specularColor.r *= newMaterial.specularLevel;
             newMaterial.specularColor.g *= newMaterial.specularLevel;
             newMaterial.specularColor.b *= newMaterial.specularLevel;
             currentMaterial.setSpecularColor(newMaterial.specularColor);
             for(var i=0 ; i < newMaterial.layers.length; i++)
             {
                var layer = currentMaterial.layers[i];
                var newLayer = newMaterial.layers[i];
                if(!layer)
                {
                    layer = new GLGE.MaterialLayer();
                    layer.setMapinput(GLGE.UV1);
                    currentMaterial.addMaterialLayer(layer);
                }
 
                layer.setMapto(newLayer.mapTo);
                layer.setBlendMode(newLayer.blendMode);
                layer.setAlpha(newLayer.alpha);
 
                layer.setScaleX(newLayer.scalex);
                layer.setScaleY(newLayer.scaley);
                layer.setOffsetX(newLayer.offsetx);
                layer.setOffsetY(newLayer.offsety);
                layer.setRotZ(newLayer.rot);
                layer.setMapinput(newLayer.mapInput );
 
                var texture = layer.getTexture();
                if(texture && texture.getSrc() != newMaterial.layers[i].src)
                {
                    //currentMaterial.removeTexture(texture);
                    layer.setTexture(null);
                    texture = null;
                }
                if(!texture)
                {
                    texture = new GLGE.Texture();
                    layer.setTexture(texture);
                    currentMaterial.addTexture(texture);
                    texture.setSrc(newMaterial.layers[i].src);
                }
 
             }
             while(currentMaterial.layers.length > newMaterial.layers.length)
                currentMaterial.removeMaterialLayer(currentMaterial.layers[currentMaterial.layers.length -1])
 
    }
    function findviewnode(id)
    {
        for(var i =0; i<vwf.views.length;i++)
        {
            if(vwf.views[i].state.nodes[id].glgeObject) return vwf.views[i].state.nodes[id].glgeObject;
        }
        return null;
    }
    function findleaf(node)
    {
        if(node.getMesh && node.getMesh())
            return node;
        if(node.children)
        {
            for(var i = 0; i < node.children.length; i++)
            {
                var ret = findleaf(node.children[i]);
                if(ret)
                    return ret;
            }
        }
        return null;
    }
    this.GetMesh = function()
    {
        var root = findviewnode(this.id);
        var mesh = findleaf(root);
        
        return mesh;
    }
    this.backupMesh = function()
    {
        if(!this.GetMesh())
            return;
        var mesh = this.GetMesh().getMesh();
        if(mesh.positions)
            mesh.originalPositions = mesh.positions.slice(0);
        if(mesh.normals)
            mesh.originalNormals = mesh.normals.slice(0);
        if(mesh.faces)
            mesh.originalFaces = mesh.faces.data.slice(0);
        if(mesh.uv1set)
            mesh.originalUV1 = mesh.uv1set.slice(0);
        if(mesh.uv2set)
            mesh.originalUV2 = mesh.uv2set.slice(0);
    }
    this.restoreMesh = function()
    {
      if(!this.GetMesh())
            return;
        var mesh = this.GetMesh().getMesh();
        if(mesh.originalPositions)
            mesh.setPositions(mesh.originalPositions.slice(0));
        if(mesh.originalNormals)    
            mesh.setNormals(mesh.originalNormals.slice(0));
        if(mesh.originalFaces)
            mesh.setFaces(mesh.originalFaces.slice(0));
        if(mesh.originalUV1)        
            mesh.setUV(mesh.originalUV1.slice(0));
        if(mesh.originalUV2)
            mesh.setUV2(mesh.originalUV2.slice(0));
    }
    this.updateSelf = function()
    {
      if(!this.GetMesh())
            return;
        if(!this.GetMesh().getMesh().originalPositions)
            this.backupMesh();
        else   
            this.restoreMesh();
        if(this.GetMesh().getMesh())
            this.GetMesh().getMesh().dirtyMesh = true;		
    }
    this.dirtyStack = function()
    {
      
        this.updateStack();
    }
    this.updateStack = function()
    {
        
        this.updateSelf();
        for(var i in this.children)
        {
            return vwf.callMethod(this.children[i].id,'updateStack');
        }
        if(this.GetMesh().getMesh())
            this.GetMesh().getMesh().dirtyMesh = true;
    }
    this.GetBounds = function()
    {
        return this.boundingbox;
    }                