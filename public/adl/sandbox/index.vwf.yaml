# Copyright 2012 United States Government, as represented by the Secretary of Defense, Under
# Secretary of Defense (Personnel & Readiness).
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.

--- 
extends: http://vwf.example.com/navscene.vwf
properties:
  navmode: none
  ambientColor:
    set: |
            var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
            scene.setAmbientColor(value);
    get: |
            var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
            return scene.getAmbientColor();
  ambientR:
    set: |
            this.ambientColor = 'rgb('+value+','+this.ambientG+','+this.ambientB+')';
  ambientG:
    set: |
            this.ambientColor = 'rgb('+this.ambientR+','+value+','+this.ambientB+')';
  ambientB:
    set: |
            this.ambientColor = 'rgb('+this.ambientR+','+this.ambientG+','+value+')';            
  fogColor:
    set: |  
           var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
           scene.setFogColor(value);
    get: |
            var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
            return scene.getFogColor();
  fogR:
    set: |  
           var color = this.fogColor;
           color.r = value/255;
           
    get: |
            var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
            return scene.getFogColor().r * 255;
  fogG:
    set: |  
           var color = this.fogColor;
           color.g = value/255;
           
    get: |
            var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
            return scene.getFogColor().g* 255; 
  fogB:
    set: |  
           var color = this.fogColor;
           color.b = value/255;
           
    get: |
            var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
            return scene.getFogColor().b* 255;                
  sunR:
    set: |  
           this.sun.getColor().r = value/255;
    get: |
            this.sun.getColor().r* 255;
  sunG:
    set: |  
          this.sun.getColor().g = value/255;
    get: |
            this.sun.getColor().g* 255;
  sunB:
    set: |  
           this.sun.getColor().b = value/255;
    get: |
            this.sun.getColor().b* 255;
  sunX:
    set: |  
           this.sun.setRotX(value);
           var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
           scene.updateMatrix();
    get: |
           this.sun.getRotX();
  sunY:
    set: |  
           this.sun.setRotY(value);
           var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
           scene.updateMatrix();
    get: |
           this.sun.getRotY();
  sunZ:
    set: |  
           this.sun.setRotZ(value);
           var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
           scene.updateMatrix();
    get: |
           this.sun.getRotZ();           
  fogNear:
    set: |  
           var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
           scene.setFogNear(value);
    get: |
           var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
           return scene.getFogNear();
  fogFar:
    set: |  
           var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
           scene.setFogFar(value);
    get: |
           var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
           return scene.getFogFar();
  fogType:
    set: |  
           var scene = vwf.views[0].state.scenes["index-vwf"].glgeScene;
           scene.setFogType(value);
  materialDef:
    set: |  
           return this.setTexture(value);
    get: |  
            return this.getTexture();
  skyTexture:
    set: |
            this.CreateSky(value);
  owner:
  type: scene
  EditorData:
    fogNear:
      displayname: fogNear
      property: fogNear
      type: slider
      min: 0
      max: 2000
      step: 1
    fogFar:
      displayname: fogFar
      property: fogFar
      type: slider
      min: 0
      max: 2000
      step: 1
    fogType:
      displayname: fogType
      property: fogType
      type: choice
      labels: 
        - None
        - Linear
        - Quad
        - SkyLinear
        - SkyQuad
      values:
        - 1
        - 2
        - 3  
        - 4  
        - 5  
    fogColorR:
      displayname: fogColorR
      property: fogR
      type: slider
      min: 0
      max: 256
      step: 1
    fogColorG:
      displayname: fogColorG
      property: fogG
      type: slider
      min: 0
      max: 256
      step: 1 
    fogColorB:
      displayname: fogColorB
      property: fogB
      type: slider
      min: 0
      max: 256
      step: 1
    ambientR:
      displayname: ambientR
      property: ambientR
      type: slider
      min: 0
      max: 256
      step: 1  
    ambientG:
      displayname: ambientG
      property: ambientG
      type: slider
      min: 0
      max: 256
      step: 1  
    ambientB:
      displayname: ambientB
      property: ambientB
      type: slider
      min: 0
      max: 256
      step: 1        
    sunColorB:
      displayname: sunColorB
      property: sunB
      type: slider
      min: 0
      max: 256
      step: 1
    sunColorR:
      displayname: sunColorR
      property: sunR
      type: slider
      min: 0
      max: 256
      step: 1
    sunColorG:
      displayname: sunColorG
      property: sunG
      type: slider
      min: 0
      max: 256
      step: 1
    sunRotX:
      displayname: sunRotX
      property: sunX
      type: slider
      min: 0
      max: 3.14
      step: .1
    sunRotY:
      displayname: sunRotY
      property: sunY
      type: slider
      min: 0
      max: 3.14
      step: .1   
    sunRotZ:
      displayname: sunRotZ
      property: sunZ
      type: slider
      min: 0
      max: 3.14
      step: .1
    skyTexture:
      displayname: skyTexture
      property: skyTexture
      type: choice
      labels: 
        - CloudyNoon
        - Morning
        - Evening
        - Morning2
        - Storm
        - ThunderStorm
        - Night1
        - Night2
        - Bright
      values:
        - cloudy_noon
        - early_morning
        - evening  
        - morning  
        - stormy
        - StormClouds   
        - night1
        - night2
        - bright
events:
  keyDown:
  keyUp:
methods:  
  AmLocal:
  newplayer:
  deleteplayer:
  updateCamera:
  initialize:
  receiveChat:
  CreatePlane:
  CreateSky:
  PM:
  latencyTest:
scripts:
- |
    this.initialize = function(){
 
       
       this.setCameraMode('Orbit');
       this.offset = [0,0,1];
       this.center = [0,0,0];
       this.activeCameraComp = false;
       this.loaded = false;
       this.zoom = 4;
       this.x_rot = 0.15687500000000001;
       this.y_rot = 0.5839999999999994;
       //this.updateCamera();
       this.players = [];
       this.rel_x = 0;
       this.rel_y = 0;
       this.loaded= false;
       this.leftdown= false;
       this.middledown=false;
       this.rightdown= false;
       this.last_x = 0;
       this.last_y = 0;
       this.navmode = 'none';
     //  this.PickOptions = new GLGE.CPUPickOptions();
     //  this.PickOptions.UserRenderBatches = true;
      
        $('#index-vwf').mousedown(function(e){this.localpointerDown(e);}.bind(this));
        $('#index-vwf').mouseup(function(e){this.localpointerUp(e);}.bind(this));
        $('#index-vwf').mouseleave(function(e)
        {
            if($(e.toElement).hasClass('glyph'))
            {
            
            }
            else
            {
            
                this.localpointerUp(e);
            }
            
        }.bind(this));
        $('#index-vwf').mousemove(function(e){this.localpointerMove(e);}.bind(this));

       this.updateCallbacks = [];
       this.OwnedPrims = [];
      
       findcamera().fov = 70;
       findcamera().updateProjectionMatrix();
       var ground = new THREE.Mesh(new THREE.PlaneGeometry(250,250,1,1), new THREE.MeshPhongMaterial());
       ground.PickPriority = -1;
       
       
       var grassTex = THREE.ImageUtils.loadTexture('textures/grid2.gif');
       
      
       ground.material.map = grassTex;
        grassTex.wrapS = THREE.RepeatWrapping;
        grassTex.wrapT = THREE.RepeatWrapping;
        grassTex.repeat.x = 250/9;
        grassTex.repeat.y = 250/9;
       grassTex.anisotropy  = _dRenderer.getMaxAnisotropy();
       this.groundplane = ground;
       
       findscene().add(ground);
       
       var l = new THREE.DirectionalLight();
       this.sun = l;
       findscene().add(l);
       this.sun.position.x = 1;
       this.sun.position.y = 1;
       this.sun.position.z = 4;
       this.sun.intensity = .8;
       
       this.CreateSky('white');
       /*findscene().setAmbientColor('rgb(200,200,200)');
       
       
      
       
       
       
       findscene().setFogType(GLGE.FOG_QUADRATIC);
       findscene().setFogFar(360);
       findscene().setFogNear(100);
       findscene().setFogColor('#FFFFFF');
       
       */
         if(this.id == 'Scene-vwf') return;
          this.prerendercallback = this.prerender.bind(this);
          $(document).bind('prerender',this.prerendercallback);
          this.createNameTag();
          this.updateCamera();
    }
    this.latencyTest = function(e)
    {
        if(this.moniker == this.client)
        {
            var time = new Date(e.time);
            var thistime = (new Date()) - time;
            _Notifier.alert("The round trip time to the server was: " + thistime +"ms");
        }
    }
    this.keyDown = function(e)
    {
      for(var i in this.children)
        this.children[i].keyDown(e);
    }
    this.keyUp = function(e)
    {
       for(var i in this.children)
        this.children[i].keyUp(e);
    }
    this.CreatePlane = function(width,height)
    {
        
        var hw = width/2;
        var hh = height/2;
        
        var planemesh = new GLGE.Mesh();
       
        var planeobj = new GLGE.Object();
        planeobj.PickPriority = 0;
        planeobj.setMesh(planemesh);
        planemesh.setPositions([-hw,-hh,-.001, hw,-hh,-.001, hw,hh,-.001, -hw,hh,-.001]);
        planemesh.setTangents([-hw,-hh,0, hw,-hh,0, hw,hh,0, -hw,hh,0]);
        planemesh.setFaces([0,1,2,2,3,0]);
        planemesh.setUV([0,0,250/4 ,0,250/4,250/4,0,250/4]);
        findscene().addChild(planeobj);
        planeobj.InvisibleToCPUPick = false;
        return planeobj;
    }
    this.CreateSky = function(sky_name)
    {
        
        if(this.skycube)
            this.skycube.parent.remove(this.skycube);
       //var sky_name = 'cloudy_noon';
       var urls = [];

        
        urls.push('skys/'+sky_name+'_FR.jpg');
        urls.push('skys/'+sky_name+'_BK.jpg');
        urls.push('skys/'+sky_name+'_LF.jpg');
        urls.push('skys/'+sky_name+'_RT.jpg');
        urls.push('skys/'+sky_name+'_DN.jpg');
        urls.push('skys/'+sky_name+'_UP.jpg');
       
       
        

       var skyCubeTexture = THREE.ImageUtils.loadTextureCube(urls);
            skyCubeTexture.format = THREE.RGBFormat;
            skyCubeTexture.generateMipmaps = true;
            skyCubeTexture.minFilter = THREE.LinearFilter;
            skyCubeTexture.magFilter = THREE.LinearFilter;
            skyCubeTexture.wrapS = THREE.ClampToEdgeWrapping;
            skyCubeTexture.wrapT = THREE.ClampToEdgeWrapping;

            
       
       this.skymaterial = new THREE.MeshBasicMaterial();
       this.skymaterial.side = 1;
       this.skymaterial.envMap = skyCubeTexture;
       this.skycube = new THREE.Mesh(new THREE.CubeGeometry(1000,1000,1000), this.skymaterial);
       this.skycube.renderDepth = -1;
       this.skycube.depthWrite = false;
       this.skycube.depthCheck = false;
       findscene().add(this.skycube);
        
    }
    this.removeUpdateCallback = function(m)
    {
        this.updateCallbacks.splice(m,1);
    }
    this.addUpdateCallback = function(val)
    {
        this.updateCallbacks.push(val);
        return this.updateCallbacks.length-1;
    }
    this.callUpdateCallbacks = function()
    {
        
        for(var i =0; i<this.updateCallbacks.length; i++)
         this.updateCallbacks[i](this);
    }
    this.followObject = function(value)
    {
        if(this.objectFollowed)
        {
            if(this.objectFollowed.updateCallbacks)
            {
                this.objectFollowed.updateCallbacks.splice(this.followcallbacknum,1);
            }
        }
        if(value)
        {
            if(value.updateCallbacks)
            {
                value.updateCallbacks.push(this.updateCamera.bind(this));
                this.followcallbacknum = value.updateCallbacks.length;
            }
        }
        this.objectFollowed = value; 
        if(this.objectFollowed)
        this.oldRotZ = vwf.getProperty(this.objectFollowed.id,'rotZ');
    }
    this.targetUpdated = function(obj)
    {
        if(typeof(obj) == "string")
            obj = vwf_view.kernel.kernel.models[0].model.nodes[obj];
        if(obj)
        {
        this.center = obj.translation;
        if(obj.followOffset != null)
            this.center = GLGE.addVec3(obj.translation,obj.followOffset);
        }
        
    }
    this.lookat = function(posfrom,posto,pointfront)
    {
                
                var to = GLGE.subVec3(posfrom,posto);
                to = GLGE.scaleVec3(to,1.0/GLGE.lengthVec3(to));
                var a = GLGE.crossVec3(pointfront,to);
                var tofront = goog.vec.Quaternion.createFromValues( a[0], a[1], a[2], 1 + GLGE.dotVec3(pointfront,to) );    
                var angle = 0; var axis = [0,0,1];
                var  tofront_norm = [];
                goog.vec.Quaternion.normalize(tofront,tofront_norm);    
                var currentrot = [];
               
                angle = goog.vec.Quaternion.toAngleAxis(tofront_norm,axis);
                return [axis[0],axis[1],axis[2],angle/0.0174532925];   
    }
    this.multTranslate=  function(mat, translate, result) {
     
        if(mat == undefined) return;
        if (result === undefined) {
            result = [];
        }
        if (result !== mat) {
            for(var i = 0; i < mat.length; i++)
                result.push(mat[i]);
        }

        var val;
        if (translate[0] !== 0.0) {
            val = translate[0];
            result[12] += val * mat[0];
            result[13] += val * mat[1];
            result[14] += val * mat[2];
            result[15] += val * mat[3];
        }

        if (translate[1] !== 0.0) {
            val = translate[1];
            result[12] += val * mat[4];
            result[13] += val * mat[5];
            result[14] += val * mat[6];
            result[15] += val * mat[7];
        }

        if (translate[2] !== 0.0) {
            val = translate[2];
            result[12] += val * mat[8];
            result[13] += val * mat[9];
            result[14] += val * mat[10];
            result[15] += val * mat[11];
        }
        return result;
    },
    this.normalize = function(vec)
    {   
    
        if(vec == undefined) return;
        return GLGE.scaleVec3(vec,1.0/GLGE.lengthVec3(vec));
    }
    this.makeLookAt = function(eye, center, up, result) {
    
        if(eye == undefined) return;
       
        if (result === undefined) {
            result = [];
        }

        var f = GLGE.subVec3(center, eye);
        f = this.normalize(f);

        var s = GLGE.subVec3(f, up);
        s = this.normalize(s);

        var u = GLGE.crossVec3(s, f);
        u =this.normalize(u);

        // s[0], u[0], -f[0], 0.0,
        // s[1], u[1], -f[1], 0.0,
        // s[2], u[2], -f[2], 0.0,
        // 0,    0,    0,     1.0

        result[0]=s[0]; result[1]=u[0]; result[2]=-f[0]; result[3]=0.0;
        result[4]=s[1]; result[5]=u[1]; result[6]=-f[1]; result[7]=0.0;
        result[8]=s[2]; result[9]=u[2]; result[10]=-f[2];result[11]=0.0;
        result[12]=  0; result[13]=  0; result[14]=  0;  result[15]=1.0;
        
        var tra = [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];        
        tra[12] = -eye[0];
        tra[13] = -eye[1];
        tra[14] = -eye[2];
        var newresult = GLGE.mulMat4(result,tra);
        return newresult;
    }
    this.GetWorldPickRay = function(e)
    {

       var OldX = e.clientX - $('#index-vwf').offset().left;
        var OldY = e.clientY - $('#index-vwf').offset().top;

        var screenmousepos = [OldX/document.getElementById('index-vwf').clientWidth,OldY/document.getElementById('index-vwf').clientHeight,0,1];
        screenmousepos[0] *= 2;
        screenmousepos[1] *= 2;
        screenmousepos[0] -= 1;
        screenmousepos[1] -= 1;
        screenmousepos[1] *= -1;
        var worldmousepos = GLGE.mulMat4Vec4(GLGE.inverseMat4(getViewProjection()),screenmousepos);
        worldmousepos[0] /= worldmousepos[3];
        worldmousepos[1] /= worldmousepos[3];
        worldmousepos[2] /= worldmousepos[3];


        var campos = [_Editor.findcamera().position.x,_Editor.findcamera().position.y,_Editor.findcamera().position.z];
        var ray = GLGE.subVec3(worldmousepos,campos);
        var dist = GLGE.lengthVec3(ray);
        ray = GLGE.scaleVec3(ray,1.0/GLGE.lengthVec3(ray));
        return ray;
    }
    this.intersectLinePlane = function(ray,raypoint,planepoint,planenormal)
    {
        var n = GLGE.dotVec3(GLGE.subVec3(planepoint,raypoint),planenormal);
        var d = GLGE.dotVec3(ray,planenormal);
        if(d == 0)
            return null;

        var dist = n/d;

        return dist;
    }
    this.localpointerDown = function( parms, pickInfo ){
     
     
      if(parms.which == 1) this.leftdown = true;
      if(parms.which == 2) this.middledown = true;
      if(parms.which == 3) this.rightdown = true;
     
      if(this.objectFollowed)
        this.oldRotZ = vwf.getProperty(this.objectFollowed.id,'rotZ');
     
      if(parms.which == 3 || parms.which == 2 && (this.cameramode == 'Orbit' || this.cameramode == 'Free'))
        {
        // Ask the browser to lock the pointer
       // $('#index-vwf')[0].requestPointerLock();
        }      
     
      this.last_x = parms.clientX/window.screen.width;
      this.last_y = parms.clientY/window.screen.height;
      
      if(this.cameramode == 'Navigate')
      {
             
           var campos = [_Editor.findcamera().position.x,_Editor.findcamera().position.y,_Editor.findcamera().position.z];
           var ray = this.GetWorldPickRay(parms);

           var dxy = this.intersectLinePlane(ray,campos,[0,0,0],[0,0,1]);
           var oldintersectxy = GLGE.addVec3(campos,GLGE.scaleVec3(ray,dxy));
           
            this.groundplane.PickPriority = 0;
           oldintersectxy = _Editor.ThreeJSPick(campos,ray,this.PickOptions).point;
            this.groundplane.PickPriority = -1;
           oldintersectxy = [oldintersectxy.x,oldintersectxy.y,oldintersectxy.z];
           this.navpoint =  oldintersectxy;
      }
     
    }
    this.localpointerUp = function( parms, pickInfo ){
      
      if(parms.which == 1) this.leftdown = false;
      if(parms.which == 3) this.rightdown = false;
      if(parms.which == 2) this.middledown = false;
      if(parms.which == 2 || parms.which == 3)
        {
        // Ask the browser to lock the pointer
        //document.exitPointerLock();
        }    
    }
    this.localpointerMove = function( parms, pickInfo ){

      
      if(document.AxisSelected != null)  
      if(document.AxisSelected != -1)
        return;
        
      if(this.rel_x == undefined) return;
      
      this.rel_x = this.last_x - parms.clientX/window.screen.width;
      this.rel_y = this.last_y - parms.clientY/window.screen.height;
      
      if((this.rightdown==true || this.middledown==true))
      {
        this.rel_x = -(parms.originalEvent.webkitMovementX || parms.originalEvent.mozMovementX || parms.originalEvent.MovementX)/1000 || this.rel_x;
        this.rel_y = -(parms.originalEvent.webkitMovementY || parms.originalEvent.mozMovementY || parms.originalEvent.MovementY)/1000 || this.rel_y;
      }
      
      if((this.rightdown==true && this.middledown==false))
      {
        
        if(this.objectFollowed)
        {  
            this.oldRotZ += this.rel_x*10 || 0;
            vwf_view.kernel.setProperty(this.objectFollowed.id,'rotZ', this.oldRotZ);
            //_Editor.findviewnode(this.objectFollowed.id).setRotZ(this.oldRotZ);
            
        }
        
        this.x_rot += this.rel_x;
        this.y_rot += this.rel_y;
        this.updateCamera();
        
      }
      
      if((this.cameramode == 'Orbit'|| this.cameramode == 'Free' ) && this.middledown == true )
      {
        
        
        var screenmousepos = [(parms.clientX-this.rel_x*1000)/window.screen.width,(parms.clientY-this.rel_y*1000)/window.screen.height,0,1];
        screenmousepos[0] *= 2;
        screenmousepos[1] *= 2;
        screenmousepos[0] -= 1;
        screenmousepos[1] -= 1;
        screenmousepos[1] *= -1;
        var worldmousepos = GLGE.mulMat4Vec4(GLGE.inverseMat4(getViewProjection()),screenmousepos);
        worldmousepos[0] /= worldmousepos[3];
        worldmousepos[1] /= worldmousepos[3];
        worldmousepos[2] /= worldmousepos[3];
       
        screenmousepos = [this.last_x,this.last_y,0,1];
        screenmousepos[0] *= 2;
        screenmousepos[1] *= 2;
        screenmousepos[0] -= 1;
        screenmousepos[1] -= 1;
        screenmousepos[1] *= -1;
        var worldmousepos2 = GLGE.mulMat4Vec4(GLGE.inverseMat4(getViewProjection()),screenmousepos);
        worldmousepos2[0] /= worldmousepos2[3];
        worldmousepos2[1] /= worldmousepos2[3];
        worldmousepos2[2] /= worldmousepos2[3];
       
       var panfactor = 50;
       if(this.cameramode == 'Free')
       panfactor = 50;
       
       console.log(this.zoom);
        this.center = GLGE.addVec3(this.center,GLGE.scaleVec3(GLGE.subVec3(worldmousepos2,worldmousepos),panfactor * this.zoom));
        this.updateCamera();
        
      }
      
      if(this.cameramode == 'Navigate' && this.middledown == true)
      {   
           var campos = [_Editor.findcamera().position.x,_Editor.findcamera().position.y,_Editor.findcamera().position.z];
           var ray = this.GetWorldPickRay(parms);

           var dxy = this.intersectLinePlane(ray,campos,[0,0,this.navpoint[2]],[0,0,1]);
           var newintersectxy = GLGE.addVec3(campos,GLGE.scaleVec3(ray,dxy));
           
           var len  = GLGE.subVec3(this.navpoint,newintersectxy)
           
           this.center = GLGE.addVec3(this.center,GLGE.subVec3(this.navpoint,newintersectxy));
          
           this.updateCamera();
      }
      
      this.last_x = parms.clientX/window.screen.width;
      this.last_y = parms.clientY/window.screen.height;
    }
    this.updateCamera = function()
      {
        
        
        
        if(this.objectFollowed != null)    
            this.targetUpdated(this.objectFollowed);
        
        if(this.cameramode != '3RDPerson' && this.cameramode != 'FirstPerson')
        {
            if(this.x_rot == undefined) return;
            var xmatrix = GLGE.angleAxis(this.x_rot*10,[0,0,1]);
            
            var offset = GLGE.mulMat4Vec3(xmatrix,[1,0,0]);
            offset = GLGE.scaleVec3(offset,1/GLGE.lengthVec3(offset));
            var side = GLGE.crossVec3([0,0,1],offset);
            
            if(this.y_rot < .479 ) this.y_rot = .479;
            if(this.y_rot > .628 && this.cameramode != 'Free') this.y_rot = .628;
            if(this.y_rot > .783 && this.cameramode == 'Free') this.y_rot = .783;
            
            var crossmatrix = GLGE.angleAxis(this.y_rot*10,side);
            var stage2offset = GLGE.mulMat4Vec3(crossmatrix,offset);
            
            stage2offset = GLGE.scaleVec3(stage2offset,1/GLGE.lengthVec3(stage2offset));
            var finaloffset = GLGE.scaleVec3(stage2offset,this.zoom);
            if(this.center[2] < .05)
             this.center[2] = .05;
            var finalpos = GLGE.addVec3(finaloffset,this.center);
            
            //this.camera.translation = finalpos;
            findcamera().position = to3Vec(finalpos[0],finalpos[1],finalpos[2]);
            findcamera().lookAt(to3Vec(this.center));
            findcamera().far = 1000;
            findcamera().near = .1;
        }else if(this.cameramode == 'FirstPerson')
        {
            //this.oldRotZ var xmatrix = GLGE.angleAxis(this.x_rot*10,[0,0,1]);
            var rotation = this.objectFollowed.rotation;
            var xmatrix = GLGE.angleAxis(this.oldRotZ,[0,0,1]);
            var offset = GLGE.mulMat4Vec3(xmatrix,[0,1.5,.5]);
            
            offset = GLGE.scaleVec3(offset,1/GLGE.lengthVec3(offset));
            var side = GLGE.crossVec3([0,0,1],offset);
           
            if(this.y_rot < .479 ) this.y_rot = .479;
            if(this.y_rot > .783 ) this.y_rot = .783;
            
            var crossmatrix = GLGE.angleAxis(this.y_rot*10,side);
            var stage2offset = GLGE.mulMat4Vec3(crossmatrix,offset);
            
            stage2offset = GLGE.scaleVec3(stage2offset,1/GLGE.lengthVec3(stage2offset));
            var finaloffset = GLGE.scaleVec3(stage2offset,this.zoom);
            if(this.center[2] < .05)
             this.center[2] = .05;
            var finalpos = GLGE.addVec3(finaloffset,this.center);
            
            //this.camera.translation = finalpos;
            findcamera().position = to3Vec(finalpos[0],finalpos[1],finalpos[2]);
            findcamera().lookAt(to3Vec(this.center));
            findcamera().far = 1000;
            findcamera().near = .1;
            this.zoom = .0001;
            
        }else  if(this.cameramode == '3RDPerson')
        {
            
            var xmatrix = GLGE.angleAxis(this.oldRotZ,[0,0,1]);
            var offset = GLGE.mulMat4Vec3(xmatrix,[0,1.5,.5]);
            
            var finaldist = GLGE.lengthVec3(offset);  
            offset = GLGE.scaleVec3(offset,1/finaldist);            
            var start = GLGE.addVec3(this.center,GLGE.scaleVec3(offset,.3));
            
            var oldpickstate = findviewnode(this.objectFollowed.id).PickPriority;
            
            var hit = _Editor.ThreeJSPick(start,GLGE.scaleVec3(offset,1),this.PickOptions);
            if(hit)
            {
                finaldist = Math.min(finaldist,hit.distance-.2);
            }
            findviewnode(this.objectFollowed.id).PickPriority = oldpickstate;
            offset = GLGE.scaleVec3(offset,finaldist);
            
            var finalpos = GLGE.addVec3(offset,start);
            findcamera().position = to3Vec(finalpos[0],finalpos[1],finalpos[2]);
            findcamera().lookAt(to3Vec(this.center));
            
        }
        this.callUpdateCallbacks();
        findcamera().updateMatrixWorld();
        findcamera().updateMatrix();
      }
      function findscene()
      {
             return vwf.views[0].state.scenes["index-vwf"].threeScene;
      }
      function findcamera()
      {
             return vwf.views[0].state.scenes["index-vwf"].camera.threeJScameras[vwf.views[0].state.scenes["index-vwf"].camera.defaultCamID];
      }
      function matcpy(mat)
      {
        var newmat = [];
        for(var i = 0; i < 16; i++)
            newmat[i] = mat[i];
        return newmat;    
      }
      function getViewProjection()
      {
        var cam = findcamera();
        cam.matrixWorldInverse.getInverse( cam.matrixWorld );

        var _viewProjectionMatrix = new THREE.Matrix4();
        _viewProjectionMatrix.multiplyMatrices( cam.projectionMatrix, cam.matrixWorldInverse );


        return GLGE.transposeMat4(_viewProjectionMatrix.flattenToArray([]));
      }
      function to3Vec(vec,two,three)
      {
        if(vec.length)
            return new THREE.Vector3(vec[0],vec[1],vec[2]);
        else
            return new THREE.Vector3(vec,two,three);
      }
    this.setCameraMode = function(mode)
    {
        this.cameramode = mode;
        if(this.cameramode == 'Orbit')
            this.followObject(null);
        if(this.cameramode == 'Free')
        {
           this.ReprojectCameraCenter();
           this.followObject(null);
        }
    }
    this.orbitPoint = function(point)
    {
        this.setCameraMode('Orbit');
        var campos = [_Editor.findcamera().position.x,_Editor.findcamera().position.y,_Editor.findcamera().position.z];
        var diff = GLGE.subVec3(campos,point);
        var length = GLGE.lengthVec3(diff);
        diff = GLGE.scaleVec3(diff,1.0/length);
        //this.offset = diff;
        this.zoom = length;
        this.center = point;
        this.objectFollowed = null;
        
    }
    this.ReprojectCameraCenter = function()
    {
            var campos = [findcamera().position.x,findcamera().position.y,findcamera().position.z];
            var worldmousepos  = this.GetCameraCenterRay();
            worldmousepos = GLGE.scaleVec3(worldmousepos,.4);
            this.center = GLGE.addVec3(worldmousepos,campos);  
            this.zoom = .4;
    }
    this.GetCameraCenterRay = function()
    {
        var screenmousepos = [0,0,0,1];
        var worldmousepos = GLGE.mulMat4Vec4(GLGE.inverseMat4(getViewProjection()),screenmousepos);
        worldmousepos[0] /= worldmousepos[3];
        worldmousepos[1] /= worldmousepos[3];
        worldmousepos[2] /= worldmousepos[3];


         var campos = [findcamera().position.x,findcamera().position.y,findcamera().position.z];
        var ray = GLGE.subVec3(worldmousepos,campos);
        var dist = GLGE.lengthVec3(ray);
        ray = GLGE.scaleVec3(ray,1.0/GLGE.lengthVec3(ray));
        return ray;
    }    
    this.pointerLeave = function( parms ){

    }
    this.pointerWheel = function( parms, pickInfo ) {
       
        if(this.client != this.moniker) return;
        if(this.cameramode != 'Navigate' && this.cameramode != 'Free')
        { 
            if(pickInfo.wheel.deltaY < 0 )
            this.zoom *= .9;
            else
            this.zoom *= 1.1;
        }
        if(this.cameramode == 'Navigate')
        {  
            this.center = GLGE.addVec3(this.center,GLGE.scaleVec3(GLGE.subVec3(this.navpoint,this.center),.05));
            this.zoom = this.zoom + (3- this.zoom )*.01;
        }
        
        if(this.cameramode == 'Free')
        { 
            if(pickInfo.wheel.deltaY > 0 )
            this.center = GLGE.subVec3(this.center,this.GetCameraCenterRay());
            else
            this.center = GLGE.addVec3(this.GetCameraCenterRay(),this.center);
            
        }
        if(this.cameramode == 'FirstPerson' && pickInfo.wheel.deltaY > 0)
        {
            this.cameramode = '3RDPerson';
        }
        else if(this.cameramode == '3RDPerson' && pickInfo.wheel.deltaY < 0)
        {
            this.y_rot =.6245;
            this.cameramode = 'FirstPerson';
        }
        this.updateCamera();
    }
    this.deleteplayer = function(e)
    {
        
       
        var player = vwf_view.kernel.kernel.models[0].model.nodes[e];
        if(!player)
            player = vwf_view.kernel.kernel.models[0].model.nodes['-object-Object-'+e];
        var num = player.PlayerNumber;
        PlayerDeleted(num);
        
        player.deinitialize();
        
        
        
    }
    this.receiveChat = function(e)
    {
        ChatMessageReceived(e);
    }
    this.PM = function(e)
    {
        PMReceived(e);
    }
    function nodeExists(tempid)
    {
        for(var i in vwf.models.object.objects)
            if (vwf.models.object.objects[i].properties.tempid == tempid) return true;
        
        return false;
    }
    
    function findviewnode(id)
    {
        for(var i =0; i<vwf.views.length;i++)
        {
            if(vwf.views[i].state.nodes[id].threeObject) return vwf.views[i].state.nodes[id].threeObject;
        }
        return null;
    }
    
    this.newplayer = function(e)
    {
        
       
        this.loaded = true;
        var proto = JSON.parse(e);
        //this.players.push(proto);
        //Because SendSelf will create circular messages, don't create a guy who is already created.
        var newname = "player-"+proto.properties.PlayerNumber;
        this.future(.1).updateCamera();
        if(!document[proto.properties.PlayerNumber + 'link'])
        {
            this.players.push(proto.properties.PlayerNumber);
            _UserManager.PlayerCreated(proto.properties.PlayerNumber);
           
            //This is odd. It seems like supplying an ID for the new object causes the initialize not to fire
            delete proto.id;//"player-"+proto.properties.PlayerNumber;
            proto.uri = "-object-Object-player-"+proto.properties.PlayerNumber;
            //vwf_view.kernel.kernel.createNode(proto,  function(){this.updateCamera();vwf_view.kernel.kernel.models[0].model.nodes[proto.id].initialize();
            //}.bind(this));
            this.children.create("player-"+proto.properties.PlayerNumber,proto);
            
            
            
        }
        
    }
    
    this.getTexture = function()
    {
            if(this.materialDef) return this.materialDef;    
           
            return {
                    shininess:15,
                    alpha:1,
                    ambient:{r:.8,g:.8,b:.8},
                    color:{r:1,g:1,b:1,a:1},
                    emit:{r:0,g:0,b:0},
                    reflect:0.8,
                    shadeless:false,
                    shadow:true,
                    specularColor:{r:0.5773502691896258,g:0.5773502691896258,b:0.5773502691896258},
                    specularLevel:1,
                    layers:[
                      {  alpha: 1,
                        blendMode: 0,
                        mapInput: 0,
                        mapTo: 1,
                        offsetx: 0,
                        offsety: 0,
                        rot: 0,
                        scalex: 250/9,
                        scaley: 250/9,
                        src: "textures/grid2.gif"}
                    ]
            }            
    
    }
    this.setTexture = function(value)
    {
            debugger;
             _Editor.setMaterialByDef(this.groundplane.material,value);
           // this.materialDef = value;
    }
    this.createNameTag = function()
    {
    
      var newdiv = document.createElement('img');
      
      $(newdiv).addClass('glyph');
      newdiv.style.position = 'absolute';
      newdiv.id = "Player " + this.name + 'icon';
      //newdiv.innerHTML = "" + this.name;
      $(newdiv).attr('src','../vwf/view/editorview/images/icons/scene.png');
      newdiv.style.left = '0px';
      newdiv.style.top = '0px';
      
      $('#glyphOverlay').append(newdiv);
      $(newdiv).disableSelection();
            $(newdiv).mousedown(function(e){$('#index-vwf').focus(); if(_Editor.GetSelectMode() == "None" || e.which != 1) $('#index-vwf').trigger(e)});
      $(newdiv).mouseup(function(e){$('#index-vwf').focus();$('#index-vwf').trigger(e)});
      $(newdiv).mousemove(function(e){$('#index-vwf').trigger(e)});
      $(newdiv).click(function(e){$('#index-vwf').focus(); if(_Editor.GetSelectMode() != "None") _Editor.SelectObjectPublic(this.id)}.bind(this));
      this.nametag = newdiv;
                 
    }
    this.deinitialize = function()
    {
       $(document).unbind('prerender',this.prerendercallback);
       $(this.nametag).remove();
    }
    this.prerender = function(e,viewprojection, wh, ww)
    {
        //set the skybox position
      
        this.skycube.position = findcamera().position;
   
      var div = this.nametag;
      var pos = [0,0,0];
      pos = [pos[0],pos[1],pos[2],1];
         
      
      
      var screen = GLGE.mulMat4Vec4(viewprojection,pos);
      screen[0] /= screen[3];
      screen[1] /= screen[3];
     
      screen[0] /= 2;
      screen[1] /= 2;
      screen[2] /= 2;
      screen[0] += .5;
      screen[1] += .5;
      
  
      screen[0] *= ww;
      screen[1] *= wh;
      
     
      screen[1] = wh - screen[1];

      div.style.top = (screen[1]+35)  +  'px';
      div.style.left = (screen[0]  - div.offsetWidth/2)  +'px';
     
     
      if((screen[0] < 0 || screen[0] > ww || screen[1] < 0 || screen[1] > wh))
      {
            if(div.style.display != 'none')
                div.style.display = 'none';
      }
      else
      {
          if((screen[2] > 10 || screen[2] < 0) && div.style.display != 'none')
             div.style.display = 'none';
          if(screen[2] < 10 && screen[2] > 0 && div.style.display == 'none')
             div.style.display = 'block';
      }
    }    
          

        
    
    
 
 
   

   